<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: couchlike.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: couchlike.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var EventEmitter = require('events').EventEmitter;
var url = require('url');
var util = require('util');
var async = require('async');
var couchlikeViews = require('./couchlikeViews');
var couchlikeChanges = require('./couchlikeChanges');
var nano = require('nano');
var PouchDB = require('pouchdb');
var KeepAliveAgent = require('agentkeepalive');

const DEFAULT_MAX_SOCKETS = 100;

/**
 * @global
 * @desc Enumeration of couchlike engine types.
 * @readonly
 * @enum {string}
 */
var engineType = {
	/** CouchDB server **/
	couchDB: "couchDB",
	/** PouchDB server **/
	pouchDB: "pouchDB",
	/** Couchbase Sync Gateway server **/
	couchbaseSyncGateway: "couchbaseSyncGateway"
};

/**
 * @typedef {Object} CouchlikeCapability
 * @desc Capability of a couchlike connection
 * @property {boolean} changes - TODO
 * @property {boolean} views - TODO
 * @example
 * TODO
 */

/**
 * @global
 * @desc Enumeration of couchlike capabilities.
 * @readonly
 * @enum {string}
 */
var capability = {
	/**
	 * @desc Default couchlike capability
	 * @type {CouchlikeCapability}
	 **/
	default: { },
	/**
	 * @desc CouchDB couchlike capability
	 * @type {CouchlikeCapability}
	 **/
	couchDB: {
		changes: true,
		views: true,
		viewIncludeDocs: true
	},
	/**
	 * @desc PouchDB couchlike capability
	 * @type {CouchlikeCapability}
	 **/
	pouchDB: {
		changes: true,
		views: true,
		viewIncludeDocs: true
	},
	/**
	 * @desc Couchbase Sync Gateway couchlike capability
	 * @type {CouchlikeCapability}
	 **/
	couchbaseSyncGateway: { // This is not working since the password was set on the mirrored bucket (https://groups.google.com/forum/#!topic/mobile-couchbase/6_S4BWW2a4I)
		changes: true,
		views: true,
		viewIncludeDocs: false
	}
};

var DEFAULT_COUCHBASE_PORT = 8092;
var DEFAULT_COUCHDB_PORT = 5984;
var DEFAULT_COUCHBASESYNCGATEWAY_PORT = 4984;

function copiedCouchbaseDocument(document) {
	var newDocument = JSON.parse(JSON.stringify(document));
	delete newDocument._rev;
	delete newDocument._id;
	return newDocument;
}

function looksLikePouchDBInstance(thing) {
	return thing &amp;&amp; thing.adapter &amp;&amp; thing.replicate &amp;&amp; thing.prefix === '_pouch_';
}

/**
 * @typedef {Object} CouchlikeDocument
 * @desc Couchlike document
 * @property {String} _id - TODO
 * @property {String} _rev - TODO
 * @example
 * TODO
 */
/**
 * @typedef {Object} CouchlikeConfiguration
 * @desc Couchlike configuration
 * @property {engineType} type - TODO
 * @property {CouchlikeConnection} connection - TODO
 * @example
 * TODO
 */
/**
 * @typedef {Object} CouchlikeConnection
 * @desc Connection details for a couchlike server
 * @property {String=} host - TODO
 * @property {Number=} port - TODO
 * @property {String=} username - TODO
 * @property {String=} password - TODO
 * @property {String=} bucket - TODO
 * @property {String=} bucketPassword - TODO
 * @example
 * TODO
 */
/**
 * @callback PingCallback
 * @desc Invoked following a {@link Couchlike#ping} attempt on a couchlike server.
 * @param {undefined|Error} error - If an error occurred during the operation it is returned here.
 * @param {Object} response - TODO.
 */
/**
 * @callback GetCallback
 * @desc Invoked following a get request on a couchlike server.
 * @param {undefined|Error} error - If an error occurred during the operation it is returned here.
 * @param {Object} response - TODO.
 */
/**
 * @callback SetCallback
 * @desc Invoked following a set request on a couchlike server.
 * @param {undefined|Error} error - If an error occurred during the operation it is returned here.
 * @param {Object} response - TODO.
 */
/**
 * @callback RemoveCallback
 * @desc Invoked following a remove request on a couchlike server.
 * @param {undefined|Error} error - If an error occurred during the operation it is returned here.
 * @param {Object} response - TODO.
 */

/**
 * @classdesc Root class for all couchlike functionality. Instantiate a new Couchlike instance, passing a {@link CouchlikeConfiguration} to the constructor.
 * @desc TODO.
 * @constructor
 * @augments EventEmitter
 * @property {CouchlikeConfiguration} config - TODO
 * @property {CouchlikeViews} views - TODO
 * @property {CouchlikeChanges} changes - TODO
 * @param {CouchlikeConfiguration=} config - TODO
 * @example
 * TODO
 */
function Couchlike(config) {
	this.config = config ? config : { type: engineType.pouchDB };
	this.capability = capability.default;
	if (this.config.connection) {
		if (!this.config.connection.bucket) { this.config.connection.bucket = this.config.connection.database; }
		if (this.config.connection.database) { delete this.config.connection.database; }
	}

	//  \/ \/ \/ \/ \/ HEARTBEAT \/ \/ \/ \/ \/
	var that = this;
	var HEARTBEAT_TIMEOUT = 10 * 1000; // 10 seconds
	this.heartbeatToConfigType =function(heartbeat) {
		var response = engineType.couchDB;
		if (heartbeat &amp;&amp; heartbeat.vendor &amp;&amp; heartbeat.vendor.name &amp;&amp; heartbeat.vendor.name.indexOf &amp;&amp; (heartbeat.vendor.name.indexOf('Couchbase') >= 0)) { response = engineType.couchbaseSyncGateway; }
		return response;
	};

	this.configTypeFromHeartbeat = function(callback) {
		if (this.currentHeartbeatValid()) { return callback(null, this.heartbeatToConfigType(this.currentHeartbeat())); }
		this.engine.request({}, function(err, heartbeat) {
			if (err) { return callback(err); }
			var configType = that.heartbeatToConfigType(heartbeat);
			that.updateCurrentHeartbeat(heartbeat, configType);
			return callback(null, configType);
		});
	};

	this.updateCurrentHeartbeat = function(heartbeat, configType) {
		this.doSetTypeDependentStuff(configType);
		this.currentHeartbeat.value = heartbeat;
		this.currentHeartbeat.setAt = Date.now();
	};

	this.currentHeartbeat = function() {
		return this.currentHeartbeat.value;
	};

	this.currentHeartbeatValid = function() {
		return (this.currentHeartbeat() &amp;&amp; this.currentHeartbeat.setAt &amp;&amp; (Date.now() &lt; (this.currentHeartbeat.setAt + HEARTBEAT_TIMEOUT)));
	};

	this.configType = function(callback) {
		if (this.config.type) { return callback(null, this.config.type); }
		return this.configTypeFromHeartbeat(callback);
	};

	this.doSetTypeDependentStuff = function(configType) {
		that.capability = (configType === engineType.pouchDB) ? capability.pouchDB : (configType === engineType.couchbaseSyncGateway) ? capability.couchbaseSyncGateway : capability.couchDB;
		that._isCouchbasey = (configType === engineType.couchbaseSyncGateway) ? true : false;
	};

	this.setTypeDependentStuff = function() {
		this.configType(function(err, configType) {
			if (err) { throw err; }
			that.doSetTypeDependentStuff(configType);
		});
	};
	//  /\ /\ /\ /\ /\ HEARTBEAT /\ /\ /\ /\ /\

	this.engine = null;
	if (this.config &amp;&amp; (!this.config.type || this.config.type === engineType.couchDB || this.config.type === engineType.couchbaseSyncGateway)) {
		if (!/^http/.test(this.config.connection.host)) { this.config.connection.host = 'http://'+this.config.connection.host; }
		var urlConn = url.parse(this.config.connection.host);
		urlConn.host = null;
		if (this.config.connection.username &amp;&amp; this.config.connection.password) { urlConn.auth = this.config.connection.username+':'+this.config.connection.password; }
		if (this.config.connection.port) { urlConn.port = this.config.connection.port; }
		if (!urlConn.port) { urlConn.port = (this.config.type === engineType.couchDB) ? DEFAULT_COUCHDB_PORT : DEFAULT_COUCHBASESYNCGATEWAY_PORT; }
		var nanoConfig = { url: url.format(urlConn) };
		if (this.config.connection.strictSSL !== (void 0)) {
			nanoConfig.requestDefaults = { strictSSL: this.config.connection.strictSSL };
			if (!this.config.connection.strictSSL) { process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"; }
		} else if (this.config.connection.ca !== (void 0)) {
			nanoConfig.requestDefaults = { ca: this.config.connection.ca };
		} else { nanoConfig.requestDefaults = {}; }
		var useAgent = new KeepAliveAgent({	maxSockets: this.config.connection.maxSockets ? this.config.connection.maxSockets : DEFAULT_MAX_SOCKETS });
		nanoConfig.requestDefaults.agent = useAgent;
		this.engine = nano(nanoConfig);
		this.engine.bucket = this.engine.use(this.config.connection.bucket);
	} else if (this.config &amp;&amp; this.config.type === engineType.pouchDB) {
		this.engine = new PouchDB(this.config.connection.bucket);
	} else if (looksLikePouchDBInstance(this.config)) {
		this.engine = this.config;
		this.config = { type: engineType.pouchDB };
	} else {
		throw new Error('Unrecognised configuration');
	}

	this.setTypeDependentStuff();

	this.views = new couchlikeViews.CouchlikeViews(this);
	this.changes = new couchlikeChanges.CouchlikeChanges(this);
	this.changes.on('change', function(change) {
		that.emit('change', change);
	});
	this.changes.on('conflict', function(conflict) {
		that.emit('conflict', conflict);
	});
}

util.inherits(Couchlike, EventEmitter);

function engineTest(couch, methods, configType, callback) {
	if (!couch.engine) {
		callback(new Error('Engine not configured'));
		return false;
	} else if (!couch.config || !configType) {
		callback(new Error('Invalid config'));
		return false;
	} else if (!methods[configType]) {
		callback(new Error('Method not configured'));
		return false;
	} else { return true; }
}

function documentTestForSet(document, callback) {
	if (!document._id) {
		callback(new Error('Document must contain an _id'));
		return false;
	} else { return true; }
}

function bulkDocumentsTestForSet(documents, callback) {
	if (!documents.forEach) {
		callback(new Error('Must be an array'));
		return false;
	} else {
		var result = true;
		documents.forEach(function(document) {
			if (!result) { return result; }
			result = documentTestForSet(document);
		});
		return result;
	}
}

function bulkDocumentIdsTestForGet(documentIds, callback) {
	if (!documentIds.forEach) {
		callback(new Error('Must be an array'));
		return false;
	} else { return true; }
}

Couchlike.prototype.isCouchbasey = function() {
	return this._isCouchbasey;
};

/**
 * @desc TODO
 * @param {PingCallback=} callback
 * @example
 * TODO
 */
Couchlike.prototype.ping = function(callback) {
	var that = this;
	var methods = {
		couchDB: function() {
			that.engine.request({}, callback);
		},
		pouchDB: function() {
			if (callback) { callback(null, { ping: "ok" }); }
		},
		couchbaseSyncGateway: function() {
			that.engine.request({}, callback);
		}
	};
	this.configType(function(err, configType) {
		if (err) { return callback(err); }
		if (!engineTest(that, methods, configType, callback)) { return null; }
		methods[configType]();
	});
};

Couchlike.prototype.doGet = function(options, id, callback) {
	if (!options) { options = {}; }
	function parseResult(err, result) {
		var response = (result &amp;&amp; result.value) ? result.value : result;
		if (err) {
			if (callback) {
				var useStatusCode = err.statusCode ? err.statusCode : err.status_code ? err.status_code : err.status ? err.status : 0;
				if (useStatusCode === 404) { return callback(null, null); }
				// workarround for https://github.com/couchbase/sync_gateway/issues/844
				if (useStatusCode === 500 &amp;&amp; err.reason &amp;&amp; err.reason.indexOf &amp;&amp; err.reason.indexOf('404') > 0 ) { return callback(null, null); }
				callback(err);
			} else { throw err; }
		} else {
			if (Array.isArray(response)) {
				response = response.map(function(row) {
					var result = row.ok;
					if (!result._id) { result._id = id;	}
					return result;
				});
			} else {
				if (!response._id) { response._id = id;	}
				if (result.cas &amp;&amp; !response._rev) { response._rev = result.cas;	}
			}
			if (callback) { callback(null, response); }
		}
	}

	var that = this;
	var methods = {
		couchDB: function() {
			that.engine.bucket.get(id, parseResult);
		},
		pouchDB: function() {
			var pouchOptions = options.allRevisions ? { open_revs: 'all' } : {};
			that.engine.get(id, pouchOptions, parseResult);
		},
		couchbaseSyncGateway: function() {
			/*
			that.engine.bucket.get(id, parseResult);

			The following is the workaround for	https://github.com/couchbase/sync_gateway/issues/324
			Once this issue has been resolved, the above simple implementation should be reinstated.

			*/
			var req = {
				db: that.config.connection.bucket,
				path: id,
				method: 'GET'
			};
			if (options.allRevisions) {
				req.qs = { open_revs: 'all' };
			}
			that.engine.request(req, parseResult);
		}
	};
	this.configType(function(err, configType) {
		if (err) { return callback(err); }
		if (!engineTest(that, methods, configType, callback)) { return null; }
		methods[configType]();
	});
};

/**
 * @desc TODO
 * @param {String} id - TODO
 * @param {GetCallback=} callback
 * @example
 * TODO
 */
Couchlike.prototype.get = function(id, callback) {
	this.doGet({}, id, callback);
};

Couchlike.prototype.getRevisions = function(id, callback) {
	this.doGet({ allRevisions: true }, id, callback);
};

Couchlike.prototype.doSet = function(options, document, callback) {
	if (!options) { options = {}; }
	function parseResult(err, result) {
		if (err) { return callback(err); }
		if (result &amp;&amp; result.cas) { document._rev = result.cas; }
		else if (result &amp;&amp; result.rev) { document._rev = result.rev; }
		if (callback) { callback(err, document); }
	}

	var that = this;
	var methods = {
		couchDB: function() {
			that.engine.bucket.insert(document, parseResult);
		},
		pouchDB: function() {
			var pouchOptions = options.force ? { new_edits: false } : {};
			that.engine.put(document, pouchOptions, parseResult);
		},
		couchbaseSyncGateway: function() {
			/*
			that.engine.bucket.insert(document, document._id, parseResult);

			The following is the workaround for	https://github.com/couchbase/sync_gateway/issues/324
			Once this issue has been resolved, the above simple implementation should be reinstated.

			*/
			var req = {
				db: that.config.connection.bucket,
				path: document._id,
				body: document,
				method: 'PUT'
			};
			if (options.force) { req.qs = { new_edits: false }; }
			that.engine.request(req, function(err, result) {
				if (result) { document._rev = result.rev; }
				callback(err, document);
			});
		}
	};
	this.configType(function(err, configType) {
		if (err) { return callback(err); }
		if (!engineTest(that, methods, configType, callback)) { return null; }
		if (!documentTestForSet(document, callback)) { return null; }
		methods[configType]();
	});
};

/**
 * @desc TODO
 * @param {CouchlikeDocument} document - TODO
 * @param {SetCallback=} callback
 * @example
 * TODO
 */
Couchlike.prototype.set = function(document, callback) {
	this.doSet({}, document, callback);
};

Couchlike.prototype.force = function(document, callback) {
	this.doSet({ force: true }, document, callback);
};

/**
 * @desc TODO
 * @param {CouchlikeDocumentIds} documentIds - TODO
 * @param {BulkGetCallback=} callback
 * @example
 * TODO
 */
const BULK_THRESHOLD = 1;
Couchlike.prototype.bulkGet = function(documentIds, callback) {
	if (!documentIds || documentIds.length === 0) { return callback(null, { rows: [], total_rows: 0 }); }
	function parseResult(err, result) {
		if (callback) { callback(err, result); }
	}

	var that = this;
	var methods = {
		couchDB: function() {
			that.engine.bucket.fetch({keys: documentIds}, parseResult);
		},
		pouchDB: function() {
			that.engine.allDocs({keys: documentIds, include_docs: true}, parseResult);
		},
		couchbaseSyncGateway: function() {
			if (documentIds.length > BULK_THRESHOLD) {
				that.engine.bucket.fetch({keys: documentIds}, parseResult);
			} else {
				async.mapLimit(documentIds, BULK_THRESHOLD, that.get.bind(that), function(err, rows) {
					var result = {
						rows: rows.map(function(item) { return { doc: item }; } ),
						total_rows: rows.length
					};
					parseResult(err, result);
				});
			}
		}
	};
	this.configType(function(err, configType) {
		if (err) { return callback(err); }
		if (!engineTest(that, methods, configType, callback)) { return null; }
		if (!bulkDocumentIdsTestForGet(documentIds, callback)) { return null; }
		methods[configType]();
	});
};

/**
 * @desc TODO
 * @param {CouchlikeDocuments} documents - TODO
 * @param {BulkSetCallback=} callback
 * @example
 * TODO
 */
Couchlike.prototype.bulkSet = function(documents, callback) {
	function parseResult(err, result) {
		if (callback) { callback(err, result); }
	}

	var that = this;
	var methods = {
		couchDB: function() {
			that.engine.bucket.bulk({docs: documents}, parseResult);
		},
		pouchDB: function() {
			that.engine.bulkDocs(documents, parseResult);
		},
		couchbaseSyncGateway: function() {
			var req = {
				db: that.config.connection.bucket,
				path: '_bulk_docs',
				body: {docs: documents},
				method: 'POST'
			};
			that.engine.request(req, parseResult);
		}
	};
	this.configType(function(err, configType) {
		if (err) { return callback(err); }
		if (!engineTest(that, methods, configType, callback)) { return null; }
		if (!bulkDocumentsTestForSet(documents, callback)) { return null; }
		methods[configType]();
	});
};

/**
 * @desc TODO
 * @param {String} id - TODO
 * @param {RemoveCallback=} callback
 * @example
 * TODO
 */
Couchlike.prototype.remove = function(id, callback) {
	function parseResult(err, result) {
		if (callback) { callback(err); }
	}

	var that = this;
	var methods = {
		couchDB: function() {
			that.engine.bucket.get(id, function(err, result){
				if (err) {
					if (callback) { callback(err, result); }
				}
				else { that.engine.bucket.destroy(result._id, result._rev, parseResult); }
			});
		},
		pouchDB: function() {
			that.engine.get(id, function(err, result){
				if (err) {
					if (callback) { callback(err, result); }
				}
				else { that.engine.remove(result, parseResult); }
			});
		},
		couchbaseSyncGateway: function() {
			that.engine.bucket.get(id, function(err, result){
				if (err) {
					if (callback) { callback(err, result); }
				}
				else { that.engine.bucket.destroy(result._id, result._rev, parseResult); }
			});
		}
	};
	this.configType(function(err, configType) {
		if (err) { return callback(err); }
		if (!engineTest(that, methods, configType, callback)) { return null; }
		methods[configType]();
	});
};

Couchlike.prototype.resolve = function(resolution, callback) {
	var documents = resolution.losers.map(function(revision) {
		// revision._deleted = true;
		// return revision; // retain old data
		return { _id: revision._id, _rev: revision._rev, _deleted: true }; // remove old data
	});
	if (resolution.winner) { documents.push(resolution.winner); }
	this.bulkSet(documents, callback);
};



exports.Couchlike = Couchlike;
exports.looksLikePouchDBInstance = looksLikePouchDBInstance;
exports.engineType = engineType;
exports.PouchDB = PouchDB;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Couchlike.html">Couchlike</a></li><li><a href="CouchlikeChanges.html">CouchlikeChanges</a></li><li><a href="CouchlikeViews.html">CouchlikeViews</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:Change">Change</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BULK_THRESHOLD">BULK_THRESHOLD</a></li><li><a href="global.html#capability">capability</a></li><li><a href="global.html#engineType">engineType</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Fri Oct 06 2017 10:35:44 GMT+1100 (AEDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
